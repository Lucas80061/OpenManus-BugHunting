"""
Vulnerability Analyzer Module

This module provides functionality for analyzing, categorizing, and prioritizing
security vulnerabilities discovered during security assessments.
"""

import json
from typing import Dict, List, Optional, Any
from pathlib import Path
from dataclasses import dataclass
from enum import Enum
from datetime import datetime

from app.logger import logger


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels based on CVSS"""
    CRITICAL = "critical"  # 9.0-10.0
    HIGH = "high"         # 7.0-8.9
    MEDIUM = "medium"     # 4.0-6.9
    LOW = "low"          # 0.1-3.9
    INFO = "info"        # 0.0


class VulnerabilityCategory(Enum):
    """OWASP Top 10 and common vulnerability categories"""
    INJECTION = "injection"
    BROKEN_AUTH = "broken_authentication"
    SENSITIVE_DATA = "sensitive_data_exposure"
    XXE = "xml_external_entities"
    BROKEN_ACCESS = "broken_access_control"
    SECURITY_MISCONFIG = "security_misconfiguration"
    XSS = "cross_site_scripting"
    INSECURE_DESERIALIZATION = "insecure_deserialization"
    VULNERABLE_COMPONENTS = "vulnerable_components"
    INSUFFICIENT_LOGGING = "insufficient_logging"
    CSRF = "cross_site_request_forgery"
    SSRF = "server_side_request_forgery"
    PATH_TRAVERSAL = "path_traversal"
    COMMAND_INJECTION = "command_injection"
    INFORMATION_DISCLOSURE = "information_disclosure"
    DENIAL_OF_SERVICE = "denial_of_service"
    CRYPTOGRAPHIC_FAILURE = "cryptographic_failure"


@dataclass
class Vulnerability:
    """Vulnerability data structure"""
    id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    category: VulnerabilityCategory
    location: str
    evidence: str
    impact: str
    recommendation: str
    cve_id: Optional[str] = None
    cvss_score: Optional[float] = None
    references: List[str] = None
    discovered_by: str = "OpenManus-BugHunting"
    discovery_date: str = None
    
    def __post_init__(self):
        if self.references is None:
            self.references = []
        if self.discovery_date is None:
            self.discovery_date = datetime.now().isoformat()


class VulnerabilityAnalyzer:
    """Vulnerability analysis and categorization engine"""
    
    def __init__(self, output_dir: str = "./results"):
        """
        Initialize vulnerability analyzer
        
        Args:
            output_dir: Directory to save analysis results
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Vulnerability database
        self.vulnerabilities = []
        self.analysis_results = {}
        
        # Severity scoring rules
        self.severity_rules = self._load_severity_rules()
        
        # Category patterns
        self.category_patterns = self._load_category_patterns()
    
    def _load_severity_rules(self) -> Dict:
        """Load severity scoring rules"""
        return {
            'critical_keywords': [
                'remote code execution', 'rce', 'command injection', 'sql injection',
                'authentication bypass', 'privilege escalation', 'arbitrary file upload'
            ],
            'high_keywords': [
                'cross-site scripting', 'xss', 'path traversal', 'directory traversal',
                'file inclusion', 'xxe', 'ssrf', 'csrf'
            ],
            'medium_keywords': [
                'information disclosure', 'sensitive data', 'weak encryption',
                'session management', 'access control'
            ],
            'low_keywords': [
                'missing headers', 'version disclosure', 'weak ssl',
                'directory listing', 'verbose errors'
            ]
        }
    
    def _load_category_patterns(self) -> Dict:
        """Load vulnerability category patterns"""
        return {
            VulnerabilityCategory.INJECTION: [
                'sql injection', 'nosql injection', 'ldap injection',
                'xpath injection', 'command injection', 'code injection'
            ],
            VulnerabilityCategory.XSS: [
                'cross-site scripting', 'xss', 'reflected xss',
                'stored xss', 'dom xss'
            ],
            VulnerabilityCategory.BROKEN_AUTH: [
                'authentication bypass', 'weak password', 'session fixation',
                'credential stuffing', 'brute force'
            ],
            VulnerabilityCategory.SENSITIVE_DATA: [
                'sensitive data exposure', 'data leakage', 'information disclosure',
                'weak encryption', 'plaintext storage'
            ],
            VulnerabilityCategory.XXE: [
                'xml external entity', 'xxe', 'xml injection'
            ],
            VulnerabilityCategory.BROKEN_ACCESS: [
                'access control', 'privilege escalation', 'unauthorized access',
                'insecure direct object reference', 'idor'
            ],
            VulnerabilityCategory.SECURITY_MISCONFIG: [
                'security misconfiguration', 'default credentials',
                'unnecessary services', 'verbose errors'
            ],
            VulnerabilityCategory.CSRF: [
                'cross-site request forgery', 'csrf', 'state changing request'
            ],
            VulnerabilityCategory.SSRF: [
                'server-side request forgery', 'ssrf'
            ],
            VulnerabilityCategory.PATH_TRAVERSAL: [
                'path traversal', 'directory traversal', 'file inclusion',
                'lfi', 'rfi'
            ]
        }
    
    def add_vulnerability(self, vulnerability: Vulnerability):
        """Add a vulnerability to the analyzer"""
        self.vulnerabilities.append(vulnerability)
        logger.debug(f"Added vulnerability: {vulnerability.title}")
    
    def analyze_vulnerability_text(self, 
                                  title: str,
                                  description: str,
                                  location: str = "",
                                  evidence: str = "") -> Vulnerability:
        """
        Analyze vulnerability text and create structured vulnerability
        
        Args:
            title: Vulnerability title
            description: Vulnerability description
            location: Where the vulnerability was found
            evidence: Evidence of the vulnerability
            
        Returns:
            Structured Vulnerability object
        """
        # Determine severity
        severity = self._determine_severity(title, description)
        
        # Determine category
        category = self._determine_category(title, description)
        
        # Generate recommendations
        recommendation = self._generate_recommendation(category, severity)
        
        # Assess impact
        impact = self._assess_impact(severity, category)
        
        # Generate unique ID
        vuln_id = f"OMBH-{len(self.vulnerabilities) + 1:04d}"
        
        vulnerability = Vulnerability(
            id=vuln_id,
            title=title,
            description=description,
            severity=severity,
            category=category,
            location=location,
            evidence=evidence,
            impact=impact,
            recommendation=recommendation
        )
        
        self.add_vulnerability(vulnerability)
        return vulnerability
    
    def _determine_severity(self, title: str, description: str) -> VulnerabilitySeverity:
        """Determine vulnerability severity based on content"""
        text = f"{title} {description}".lower()
        
        # Check for critical indicators
        for keyword in self.severity_rules['critical_keywords']:
            if keyword in text:
                return VulnerabilitySeverity.CRITICAL
        
        # Check for high indicators
        for keyword in self.severity_rules['high_keywords']:
            if keyword in text:
                return VulnerabilitySeverity.HIGH
        
        # Check for medium indicators
        for keyword in self.severity_rules['medium_keywords']:
            if keyword in text:
                return VulnerabilitySeverity.MEDIUM
        
        # Check for low indicators
        for keyword in self.severity_rules['low_keywords']:
            if keyword in text:
                return VulnerabilitySeverity.LOW
        
        # Default to info if no patterns match
        return VulnerabilitySeverity.INFO
    
    def _determine_category(self, title: str, description: str) -> VulnerabilityCategory:
        """Determine vulnerability category based on content"""
        text = f"{title} {description}".lower()
        
        for category, patterns in self.category_patterns.items():
            for pattern in patterns:
                if pattern in text:
                    return category
        
        # Default category
        return VulnerabilityCategory.SECURITY_MISCONFIG
    
    def _generate_recommendation(self, category: VulnerabilityCategory, severity: VulnerabilitySeverity) -> str:
        """Generate remediation recommendations"""
        recommendations = {
            VulnerabilityCategory.INJECTION: "Implement input validation, use parameterized queries, and apply the principle of least privilege.",
            VulnerabilityCategory.XSS: "Implement proper output encoding, use Content Security Policy (CSP), and validate all user inputs.",
            VulnerabilityCategory.BROKEN_AUTH: "Implement multi-factor authentication, use strong session management, and enforce strong password policies.",
            VulnerabilityCategory.SENSITIVE_DATA: "Encrypt sensitive data at rest and in transit, implement proper access controls, and minimize data collection.",
            VulnerabilityCategory.XXE: "Disable XML external entity processing, use less complex data formats like JSON, and validate XML inputs.",
            VulnerabilityCategory.BROKEN_ACCESS: "Implement proper authorization checks, use role-based access control, and deny by default.",
            VulnerabilityCategory.SECURITY_MISCONFIG: "Review and harden security configurations, remove unnecessary services, and implement security baselines.",
            VulnerabilityCategory.CSRF: "Implement CSRF tokens, use SameSite cookie attributes, and verify referrer headers.",
            VulnerabilityCategory.SSRF: "Validate and sanitize URLs, implement allowlists for external requests, and use network segmentation.",
            VulnerabilityCategory.PATH_TRAVERSAL: "Implement proper input validation, use allowlists for file access, and apply principle of least privilege."
        }
        
        base_recommendation = recommendations.get(category, "Review and remediate the identified security issue.")
        
        if severity == VulnerabilitySeverity.CRITICAL:
            return f"URGENT: {base_recommendation} This vulnerability poses an immediate threat and should be addressed immediately."
        elif severity == VulnerabilitySeverity.HIGH:
            return f"HIGH PRIORITY: {base_recommendation} This vulnerability should be addressed as soon as possible."
        else:
            return base_recommendation
    
    def _assess_impact(self, severity: VulnerabilitySeverity, category: VulnerabilityCategory) -> str:
        """Assess the potential impact of the vulnerability"""
        impact_descriptions = {
            VulnerabilitySeverity.CRITICAL: "Complete system compromise, data breach, or service disruption",
            VulnerabilitySeverity.HIGH: "Significant security breach, unauthorized access, or data exposure",
            VulnerabilitySeverity.MEDIUM: "Moderate security risk, potential for escalation",
            VulnerabilitySeverity.LOW: "Minor security concern, limited impact",
            VulnerabilitySeverity.INFO: "Informational finding, no immediate security impact"
        }
        
        return impact_descriptions.get(severity, "Unknown impact")
    
    def analyze_scan_results(self, scan_results: Dict) -> Dict:
        """
        Analyze scan results and extract vulnerabilities
        
        Args:
            scan_results: Results from various security scans
            
        Returns:
            Analysis summary
        """
        logger.info("Analyzing scan results for vulnerabilities")
        
        vulnerabilities_found = 0
        
        # Process different types of scan results
        if 'web_scan' in scan_results:
            vulnerabilities_found += self._process_web_scan_results(scan_results['web_scan'])
        
        if 'network_scan' in scan_results:
            vulnerabilities_found += self._process_network_scan_results(scan_results['network_scan'])
        
        if 'fuzzing_results' in scan_results:
            vulnerabilities_found += self._process_fuzzing_results(scan_results['fuzzing_results'])
        
        # Generate analysis summary
        analysis_summary = self._generate_analysis_summary()
        
        logger.info(f"Analysis complete. Found {vulnerabilities_found} vulnerabilities")
        
        return analysis_summary
    
    def _process_web_scan_results(self, web_results: Dict) -> int:
        """Process web scanning results"""
        count = 0
        
        if 'vulnerabilities' in web_results:
            for vuln_data in web_results['vulnerabilities']:
                self.analyze_vulnerability_text(
                    title=vuln_data.get('type', 'Web Vulnerability'),
                    description=vuln_data.get('description', 'Web application vulnerability detected'),
                    location=vuln_data.get('location', 'Unknown'),
                    evidence=vuln_data.get('evidence', 'See scan results')
                )
                count += 1
        
        return count
    
    def _process_network_scan_results(self, network_results: Dict) -> int:
        """Process network scanning results"""
        count = 0
        
        # Check for open ports that might be vulnerabilities
        if 'open_ports' in network_results:
            risky_ports = [21, 23, 135, 139, 445, 1433, 3306, 3389, 5432]
            
            for port in network_results['open_ports']:
                if port in risky_ports:
                    service_name = self._get_service_name(port)
                    self.analyze_vulnerability_text(
                        title=f"Potentially Risky Service: {service_name}",
                        description=f"Service {service_name} is running on port {port}",
                        location=f"Port {port}",
                        evidence=f"Port scan detected open port {port}"
                    )
                    count += 1
        
        return count
    
    def _process_fuzzing_results(self, fuzzing_results: Dict) -> int:
        """Process fuzzing results"""
        count = 0
        
        if 'vulnerabilities' in fuzzing_results:
            for vuln_data in fuzzing_results['vulnerabilities']:
                self.analyze_vulnerability_text(
                    title=vuln_data.get('type', 'Input Validation Issue'),
                    description=vuln_data.get('evidence', 'Fuzzing detected potential vulnerability'),
                    location=vuln_data.get('parameter', 'Unknown parameter'),
                    evidence=f"Payload: {vuln_data.get('payload', 'N/A')}"
                )
                count += 1
        
        return count
    
    def _get_service_name(self, port: int) -> str:
        """Get service name for a port"""
        service_map = {
            21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP', 53: 'DNS',
            80: 'HTTP', 110: 'POP3', 135: 'RPC', 139: 'NetBIOS', 143: 'IMAP',
            443: 'HTTPS', 445: 'SMB', 993: 'IMAPS', 995: 'POP3S',
            1433: 'SQL Server', 3306: 'MySQL', 3389: 'RDP', 5432: 'PostgreSQL'
        }
        return service_map.get(port, f'Unknown Service (Port {port})')
    
    def _generate_analysis_summary(self) -> Dict:
        """Generate comprehensive analysis summary"""
        total_vulns = len(self.vulnerabilities)
        
        # Count by severity
        severity_counts = {}
        for severity in VulnerabilitySeverity:
            severity_counts[severity.value] = sum(
                1 for v in self.vulnerabilities if v.severity == severity
            )
        
        # Count by category
        category_counts = {}
        for category in VulnerabilityCategory:
            category_counts[category.value] = sum(
                1 for v in self.vulnerabilities if v.category == category
            )
        
        # Calculate risk score
        risk_score = self._calculate_risk_score()
        
        return {
            'total_vulnerabilities': total_vulns,
            'severity_distribution': severity_counts,
            'category_distribution': category_counts,
            'risk_score': risk_score,
            'top_categories': self._get_top_categories(),
            'critical_vulnerabilities': [
                {
                    'id': v.id,
                    'title': v.title,
                    'severity': v.severity.value,
                    'category': v.category.value
                }
                for v in self.vulnerabilities 
                if v.severity == VulnerabilitySeverity.CRITICAL
            ],
            'recommendations': self._get_priority_recommendations()
        }
    
    def _calculate_risk_score(self) -> float:
        """Calculate overall risk score (0-100)"""
        if not self.vulnerabilities:
            return 0.0
        
        severity_weights = {
            VulnerabilitySeverity.CRITICAL: 10,
            VulnerabilitySeverity.HIGH: 7,
            VulnerabilitySeverity.MEDIUM: 4,
            VulnerabilitySeverity.LOW: 2,
            VulnerabilitySeverity.INFO: 1
        }
        
        total_score = sum(
            severity_weights.get(v.severity, 1) for v in self.vulnerabilities
        )
        
        # Normalize to 0-100 scale
        max_possible = len(self.vulnerabilities) * 10
        risk_score = (total_score / max_possible) * 100 if max_possible > 0 else 0
        
        return round(risk_score, 2)
    
    def _get_top_categories(self) -> List[Dict]:
        """Get top vulnerability categories by count"""
        category_counts = {}
        for vuln in self.vulnerabilities:
            cat_name = vuln.category.value
            category_counts[cat_name] = category_counts.get(cat_name, 0) + 1
        
        # Sort by count and return top 5
        sorted_categories = sorted(
            category_counts.items(), 
            key=lambda x: x[1], 
            reverse=True
        )
        
        return [
            {'category': cat, 'count': count}
            for cat, count in sorted_categories[:5]
        ]
    
    def _get_priority_recommendations(self) -> List[str]:
        """Get prioritized recommendations"""
        recommendations = []
        
        # Critical vulnerabilities first
        critical_vulns = [v for v in self.vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL]
        if critical_vulns:
            recommendations.append("Immediately address all critical vulnerabilities")
        
        # High severity next
        high_vulns = [v for v in self.vulnerabilities if v.severity == VulnerabilitySeverity.HIGH]
        if high_vulns:
            recommendations.append("Prioritize remediation of high severity vulnerabilities")
        
        # Common categories
        top_categories = self._get_top_categories()
        if top_categories:
            top_cat = top_categories[0]['category']
            recommendations.append(f"Focus on {top_cat.replace('_', ' ')} vulnerabilities as they are most common")
        
        return recommendations
    
    def get_vulnerabilities_by_severity(self, severity: VulnerabilitySeverity) -> List[Vulnerability]:
        """Get vulnerabilities filtered by severity"""
        return [v for v in self.vulnerabilities if v.severity == severity]
    
    def get_vulnerabilities_by_category(self, category: VulnerabilityCategory) -> List[Vulnerability]:
        """Get vulnerabilities filtered by category"""
        return [v for v in self.vulnerabilities if v.category == category]
    
    def export_vulnerabilities(self, format: str = 'json') -> str:
        """Export vulnerabilities in specified format"""
        if format == 'json':
            return json.dumps([
                {
                    'id': v.id,
                    'title': v.title,
                    'description': v.description,
                    'severity': v.severity.value,
                    'category': v.category.value,
                    'location': v.location,
                    'evidence': v.evidence,
                    'impact': v.impact,
                    'recommendation': v.recommendation,
                    'discovery_date': v.discovery_date
                }
                for v in self.vulnerabilities
            ], indent=2)
        
        # Add other formats as needed
        return ""


# Example usage
def main():
    """Example usage of VulnerabilityAnalyzer"""
    analyzer = VulnerabilityAnalyzer("./test_results")
    
    # Add some test vulnerabilities
    analyzer.analyze_vulnerability_text(
        title="SQL Injection in Login Form",
        description="The login form is vulnerable to SQL injection attacks",
        location="/login.php",
        evidence="Payload: ' OR '1'='1' -- returned different response"
    )
    
    analyzer.analyze_vulnerability_text(
        title="Cross-Site Scripting in Search",
        description="Reflected XSS vulnerability in search functionality",
        location="/search.php?q=",
        evidence="Payload: <script>alert('XSS')</script> executed in browser"
    )
    
    # Generate analysis
    summary = analyzer._generate_analysis_summary()
    
    print("Vulnerability Analysis Summary:")
    print(f"Total vulnerabilities: {summary['total_vulnerabilities']}")
    print(f"Risk score: {summary['risk_score']}")
    print(f"Severity distribution: {summary['severity_distribution']}")
    
    # Export vulnerabilities
    json_export = analyzer.export_vulnerabilities('json')
    print(f"\nExported {len(analyzer.vulnerabilities)} vulnerabilities to JSON")


if __name__ == "__main__":
    main()